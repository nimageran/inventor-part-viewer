<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inventor Smart BOM - SciFi HUD</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
  
  <style>
    /* ------------------------------------------------------------------
       CORE & THEME
       ------------------------------------------------------------------ */
    :root {
      /* SCIFI PALETTE */
      --hud-bg: rgba(10, 15, 30, 0.85);
      --hud-border: #00f3ff;
      --hud-glow: 0 0 10px rgba(0, 243, 255, 0.5);
      --hud-text: #e0f7fa;
      --hud-accent: #00f3ff;
      --hud-dim: rgba(0, 243, 255, 0.3);
      
      --bg-gradient: radial-gradient(circle at center, #1b2735 0%, #090a0f 100%);
      --grid-line: rgba(0, 243, 255, 0.05);
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: var(--bg-gradient);
      font-family: 'Rajdhani', sans-serif;
      color: var(--hud-text);
    }

    /* Grid Background Effect */
    body::after {
      content: "";
      position: absolute;
      inset: 0;
      background: 
        linear-gradient(var(--grid-line) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
      background-size: 40px 40px;
      z-index: -1;
      pointer-events: none;
    }

    /* ------------------------------------------------------------------
       TOP BAR
       ------------------------------------------------------------------ */
    #top-bar {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      align-items: center;
      z-index: 100;
      
      background: var(--hud-bg);
      border: 1px solid var(--hud-dim);
      padding: 10px 25px;
      clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
      backdrop-filter: blur(5px);
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
    }

    .brand {
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      color: var(--hud-accent);
      letter-spacing: 2px;
      font-size: 14px;
      text-shadow: 0 0 8px var(--hud-accent);
      margin-right: 15px;
    }

    .file-group {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }
    
    .btn-hud {
      display: inline-block;
      padding: 6px 16px;
      font-family: 'Orbitron', sans-serif;
      font-size: 10px;
      letter-spacing: 1px;
      color: var(--hud-accent);
      border: 1px solid var(--hud-accent);
      background: rgba(0, 243, 255, 0.05);
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.3s ease;
      clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
    }
    
    .btn-hud:hover {
      background: var(--hud-accent);
      color: #000;
      box-shadow: var(--hud-glow);
    }

    input[type="file"] {
      position: absolute;
      top: 0; left: 0; opacity: 0;
      width: 100%; height: 100%;
      cursor: pointer;
    }

    #status-msg {
      font-size: 12px;
      color: var(--hud-dim);
      min-width: 150px;
      text-align: right;
    }

    /* ------------------------------------------------------------------
       LEFT TREE PANEL
       ------------------------------------------------------------------ */
    #tree-panel {
      position: fixed;
      left: 20px;
      top: 100px;
      bottom: 40px;
      width: 300px;
      background: rgba(5, 10, 20, 0.6);
      border-left: 2px solid var(--hud-dim);
      backdrop-filter: blur(4px);
      display: flex;
      flex-direction: column;
      z-index: 50;
      transition: transform 0.3s;
    }

    .panel-header {
      padding: 12px;
      background: linear-gradient(90deg, rgba(0,243,255,0.1), transparent);
      border-bottom: 1px solid var(--hud-dim);
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      color: var(--hud-accent);
      display: flex;
      justify-content: space-between;
    }

    #tree-content {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    
    /* Scrollbar Styling */
    #tree-content::-webkit-scrollbar { width: 4px; }
    #tree-content::-webkit-scrollbar-thumb { background: var(--hud-dim); }

    .tree-node { margin-left: 12px; border-left: 1px dashed rgba(255,255,255,0.1); }
    
    .tree-item {
      padding: 4px 8px;
      font-size: 13px;
      cursor: pointer;
      color: #aaa;
      transition: 0.2s;
    }
    .tree-item:hover { color: #fff; background: rgba(255,255,255,0.05); }
    .tree-item.selected {
      color: var(--hud-accent);
      background: rgba(0, 243, 255, 0.15);
      border-right: 2px solid var(--hud-accent);
    }
    
    .tree-toggle { display: inline-block; width: 14px; text-align: center; color: var(--hud-dim); }
    .tree-children { display: none; }
    .tree-children.expanded { display: block; }

    /* ------------------------------------------------------------------
       FUTURISTIC HUD (BOTTOM RIGHT)
       ------------------------------------------------------------------ */
    #hud-panel {
      position: fixed;
      bottom: 40px;
      right: 40px;
      width: 400px;
      clip-path: polygon(
        20px 0, 100% 0, 
        100% calc(100% - 20px), 
        calc(100% - 20px) 100%, 
        0 100%, 0 20px
      );
      background: var(--hud-bg);
      border: 1px solid var(--hud-border); 
      padding: 2px; 
      z-index: 50;
      display: none; 
    }

    .hud-inner {
      background: rgba(0,0,0,0.4);
      clip-path: inherit;
      padding: 20px;
      position: relative;
      border: 1px solid rgba(0, 243, 255, 0.3);
    }

    /* Decorative Corners */
    #hud-panel::before {
      content: "";
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: transparent;
      box-shadow: inset 0 0 30px rgba(0, 243, 255, 0.1);
      pointer-events: none;
      z-index: -1;
    }

    /* Animated Scanline */
    .scan-line {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 2px;
      background: var(--hud-accent);
      opacity: 0.5;
      box-shadow: 0 0 10px var(--hud-accent);
      animation: scan 3s linear infinite;
      pointer-events: none;
    }
    @keyframes scan { 0% {top:0;} 100% {top:100%;} }

    .hud-title-block {
      border-bottom: 1px solid var(--hud-dim);
      padding-bottom: 10px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
    }

    .hud-label {
      font-family: 'Orbitron', sans-serif;
      font-size: 10px;
      color: var(--hud-dim);
      letter-spacing: 2px;
    }

    .hud-part-name {
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      color: #fff;
      font-weight: 700;
      text-transform: uppercase;
      text-shadow: 0 0 5px var(--hud-accent);
    }

    .hud-grid {
      display: grid;
      gap: 8px;
    }

    .hud-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .hud-key {
      font-size: 12px;
      color: var(--hud-dim);
      text-transform: uppercase;
      font-weight: 600;
    }

    .hud-val {
      font-size: 14px;
      color: #fff;
      text-align: right;
      font-weight: 400;
      text-shadow: 0 0 2px rgba(255,255,255,0.3);
    }

    .hud-row.highlight .hud-val {
      color: var(--hud-accent);
      font-weight: 700;
    }

    .no-data {
      color: rgba(255, 50, 50, 0.7);
      font-style: italic;
      font-size: 12px;
      text-align: center;
      padding: 10px;
      border: 1px dashed rgba(255, 50, 50, 0.3);
    }

    canvas { display: block; width: 100vw; height: 100vh; outline: none; }
  </style>
</head>
<body>

  <div id="top-bar">
    <div class="brand">NIMA // BOM SCANNER</div>
    
    <div class="file-group">
      <div class="btn-hud">LOAD 3D MODEL</div>
      <input type="file" id="fileInput" accept=".glb,.gltf">
    </div>

    <div class="file-group">
      <div class="btn-hud">LOAD CSV BOM</div>
      <input type="file" id="bomInput" accept=".csv,.xlsx">
    </div>
    
    <div id="status-msg">SYSTEM READY</div>
  </div>

  <div id="tree-panel">
    <div class="panel-header">
      <span>ASSEMBLY STRUCTURE</span>
      <span style="cursor:pointer" onclick="toggleAll(true)">[+]</span>
    </div>
    <div id="tree-content">
      <div style="padding:20px; text-align:center; font-size:12px; color:var(--hud-dim);">
        NO DATA STREAM
      </div>
    </div>
  </div>

  <div id="hud-panel">
    <div class="hud-inner">
      <div class="scan-line"></div>
      
      <div class="hud-title-block">
        <div>
          <div class="hud-label">TARGET IDENTIFIED</div>
          <div class="hud-part-name" id="hud-name">--</div>
        </div>
        <div class="hud-label" id="hud-type">PART</div>
      </div>

      <div class="hud-grid" id="hud-grid">
        </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
    // ----------------------------------------------------------------------
    // 1. SETUP & VARS
    // ----------------------------------------------------------------------
    let scene, camera, renderer, controls;
    let modelRoot, selectedObject;
    let originalMaterials = new Map();
    let objectToNodeMap = new Map();
    let bomData = {}; 

    const hudPanel = document.getElementById('hud-panel');
    const hudName = document.getElementById('hud-name');
    const hudType = document.getElementById('hud-type');
    const hudGrid = document.getElementById('hud-grid');
    const statusMsg = document.getElementById('status-msg');

    initThree();

    // ----------------------------------------------------------------------
    // 2. NORMALIZATION LOGIC (CRITICAL FOR MATCHING)
    // ----------------------------------------------------------------------
    function normalizeKey(str) {
      if (!str) return '';
      let s = String(str).trim();
      
      // Remove CAD extensions
      s = s.replace(/\.(ipt|iam|glb|gltf|obj|stp|step)$/i, '');

      // Remove Instance Numbers (e.g. :1, :2)
      if (s.includes(':')) {
        s = s.split(':')[0].trim();
      }

      return s.toUpperCase();
    }

    // ----------------------------------------------------------------------
    // 3. FILE HANDLING
    // ----------------------------------------------------------------------
    
    // A. CSV Import
    document.getElementById('bomInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      statusMsg.textContent = "DECRYPTING BOM...";
      const reader = new FileReader();

      reader.onload = function(e) {
        const data = e.target.result;
        const lines = data.split(/\r?\n/).filter(l => l.trim().length > 0);
        if (lines.length < 2) return;

        const headers = lines[0].replace(/^\uFEFF/, '').split(',').map(h => h.trim().replace(/^"|"$/g, ''));
        const pnIndex = headers.findIndex(h => h.toLowerCase().includes('part') && h.toLowerCase().includes('nu'));
        
        if (pnIndex === -1) {
          alert("CRITICAL ERROR: 'Part Number' column not found in CSV.");
          return;
        }

        bomData = {}; 

        for (let i = 1; i < lines.length; i++) {
          const row = lines[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
          
          if (row[pnIndex]) {
            const rawPN = row[pnIndex].replace(/^"|"$/g, '').trim();
            const key = normalizeKey(rawPN);
            
            bomData[key] = {};
            headers.forEach((h, idx) => {
              if (row[idx]) {
                bomData[key][h] = row[idx].replace(/^"|"$/g, '').trim();
              }
            });
          }
        }
        statusMsg.textContent = `DATABASE SYNCED: ${Object.keys(bomData).length} ITEMS`;
      };

      reader.readAsText(file);
    });

    // B. 3D Model Import
    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      statusMsg.textContent = "LOADING HOLOGRAPHIC MODEL...";
      const url = URL.createObjectURL(file);
      const loader = new THREE.GLTFLoader();

      loader.load(url, (gltf) => {
        if (modelRoot) scene.remove(modelRoot);
        modelRoot = gltf.scene;
        scene.add(modelRoot);

        const box = new THREE.Box3().setFromObject(modelRoot);
        const center = box.getCenter(new THREE.Vector3());
        modelRoot.position.sub(center);
        
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        camera.position.set(maxDim, maxDim, maxDim * 1.5);
        camera.lookAt(0, 0, 0);

        originalMaterials.clear();
        objectToNodeMap.clear();
        document.getElementById('tree-content').innerHTML = '';

        modelRoot.traverse((node) => {
          if (node.isMesh) {
            originalMaterials.set(node, node.material);
          }
        });

        buildTree(modelRoot, document.getElementById('tree-content'));
        statusMsg.textContent = "VISUALIZATION ONLINE";

      }, undefined, (err) => {
        console.error(err);
        statusMsg.textContent = "UPLOAD FAILED";
      });
    });

    // ----------------------------------------------------------------------
    // 4. INTERACTION (FIXED PARENT FINDING)
    // ----------------------------------------------------------------------
    function onObjectClick(mesh) {
      // 1. CLIMB UP THE TREE
      // The mesh you clicked is often named "Solid1" or "Body1".
      // We need to find the parent container that holds the REAL Part Number.
      
      let targetObj = mesh;
      
      // If the clicked object has a generic name, grab its parent!
      // Regex checks for "Solid" followed by numbers, or "Body", or "Mesh"
      while (targetObj.parent && (
             targetObj.name.match(/^Solid\d*$/i) || 
             targetObj.name.match(/^Body\d*$/i) || 
             targetObj.name.match(/^Mesh\d*$/i) ||
             targetObj.name === "Mesh"
            )) {
          // Move selection up to the parent (The Component)
          targetObj = targetObj.parent;
      }
      
      // Safety: If we climbed all the way to the Scene, step back down one level if possible, 
      // or just use the mesh itself if it was a false alarm.
      if (targetObj.type === 'Scene') {
          targetObj = mesh; 
      }

      // 2. Highlight the ACTUAL mesh clicked (visual feedback)
      highlightObject(mesh);

      // 3. Use the TARGET object (the Parent) to find the Name
      let rawName = targetObj.userData.partNumber || targetObj.name || "Unknown";
      
      // 4. Lookup Data
      const lookupKey = normalizeKey(rawName);
      const data = bomData[lookupKey];

      // 5. Update HUD
      updateHUD(rawName, data);

      // 6. Highlight in Tree
      selectTreeNode(targetObj.isMesh ? targetObj : mesh); // Select the mesh in tree if parent isn't mapped
    }

    function updateHUD(name, data) {
      hudPanel.style.display = 'block';
      hudName.textContent = name;
      hudGrid.innerHTML = ''; 

      if (!data) {
        hudGrid.innerHTML = `<div class="no-data">NO BOM DATA FOUND FOR KEY: "${normalizeKey(name)}"</div>`;
        return;
      }

      const priorityKeys = ['Description', 'QTY', 'Stock Number', 'Material', 'Rev'];

      const addRow = (k, v, highlight=false) => {
        if (!v) return;
        const div = document.createElement('div');
        div.className = `hud-row ${highlight ? 'highlight' : ''}`;
        div.innerHTML = `<span class="hud-key">${k}</span><span class="hud-val">${v}</span>`;
        hudGrid.appendChild(div);
      };

      priorityKeys.forEach(pk => {
        const realKey = Object.keys(data).find(k => k.toLowerCase() === pk.toLowerCase());
        if (realKey) addRow(realKey, data[realKey], true);
      });

      Object.keys(data).forEach(key => {
        const isPriority = priorityKeys.some(pk => pk.toLowerCase() === key.toLowerCase());
        const isIgnored = key.toLowerCase().includes('thumbnail') || key.toLowerCase().includes('part number'); 
        
        if (!isPriority && !isIgnored) {
          addRow(key, data[key], false);
        }
      });
    }

    function highlightObject(mesh) {
      if (selectedObject && originalMaterials.has(selectedObject)) {
        selectedObject.material = originalMaterials.get(selectedObject);
      }
      selectedObject = mesh;
      
      const mat = mesh.material.clone();
      mat.emissive = new THREE.Color(0x00f3ff);
      mat.emissiveIntensity = 0.8;
      mesh.material = mat;
    }

    // ----------------------------------------------------------------------
    // 5. THREE.JS BOILERPLATE
    // ----------------------------------------------------------------------
    function initThree() {
      scene = new THREE.Scene();

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 2000);
      camera.position.set(5, 5, 10);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      renderer.domElement.addEventListener('pointerdown', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        
        if (modelRoot) {
          const intersects = raycaster.intersectObjects(modelRoot.children, true);
          if (intersects.length > 0) {
            onObjectClick(intersects[0].object);
          } else {
            hudPanel.style.display = 'none';
            if (selectedObject && originalMaterials.has(selectedObject)) {
              selectedObject.material = originalMaterials.get(selectedObject);
              selectedObject = null;
            }
          }
        }
      });

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // ----------------------------------------------------------------------
    // 6. TREE VIEW HELPERS
    // ----------------------------------------------------------------------
    function buildTree(obj, container) {
      if (!obj.name || obj.name.includes("Scene")) {
         obj.children.forEach(c => buildTree(c, container));
         return;
      }

      const node = document.createElement('div');
      node.className = 'tree-node';
      
      const item = document.createElement('div');
      item.className = 'tree-item';
      const hasKids = obj.children && obj.children.length > 0;
      
      item.innerHTML = `
        <span class="tree-toggle">${hasKids ? '▶' : '•'}</span>
        <span>${obj.name}</span>
      `;
      node.appendChild(item);

      if (hasKids) {
        const kidsDiv = document.createElement('div');
        kidsDiv.className = 'tree-children';
        obj.children.forEach(c => buildTree(c, kidsDiv));
        node.appendChild(kidsDiv);

        item.querySelector('.tree-toggle').addEventListener('click', (e) => {
          e.stopPropagation();
          kidsDiv.classList.toggle('expanded');
          e.target.textContent = kidsDiv.classList.contains('expanded') ? '▼' : '▶';
        });
      }

      if (obj.isMesh) {
        objectToNodeMap.set(obj, item);
        item.addEventListener('click', (e) => {
          if (e.target.className !== 'tree-toggle') {
            onObjectClick(obj);
          }
        });
      }

      container.appendChild(node);
    }

    function selectTreeNode(obj) {
      document.querySelectorAll('.tree-item.selected').forEach(e => e.classList.remove('selected'));
      
      const node = objectToNodeMap.get(obj);
      if (node) {
        node.classList.add('selected');
        node.scrollIntoView({ block: 'center', behavior: 'smooth' });
      }
    }
    
    function toggleAll(expand) {
       document.querySelectorAll('.tree-children').forEach(el => el.style.display = expand ? 'block' : 'none');
    }
  </script>
</body>
</html>